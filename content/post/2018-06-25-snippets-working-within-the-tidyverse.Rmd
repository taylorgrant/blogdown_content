---
title: 'Snippets: Working within the tidyverse'
author: ''
date: '2018-06-25'
slug: snippets-working-within-the-tidyverse
categories:
  - R
tags:
  - tidy data
  - tidyverse
  - dplyr
summary: "Commands, tips, and tricks that are useful within the tidyverse of packages, especially when using piped operations."
output:
  blogdown::html_page:
    toc: true
thumbnailImagePosition: left
thumbnailImage: http://res.cloudinary.com/dn83gtg0l/image/upload/v1529964813/dots.jpg
---

Snippet files are periodically updated with tips and tricks as I learn them. These commands are relevant for packages within the `tidyverse`.

```{r setup, include = FALSE}
pacman::p_load(tidyverse, glue)
```

# Using setNames to change column names

The `colnames` function can be used, as can `rename()`, but for ease of use while piping commands, the `setNames()` function is the easiest. You can either reference a vector of names or you can also reference a specific row within the data if that's necessary. For example, in [this post](https://taylorgrant.netlify.com/2018/05/using-rvest-to-import-and-html-table/){target="_blank"} after scraping an html table the column names were in the second row. In that case, we can just reference the row by its location - `%>% setNames(.[2,])` 

```{r}
names <- c("name1", "name2", "name3", "name4")

df <- tibble(
  a = sample(letters, 4),
  b = sample(1:100, 4),
  c = sample(1:100, 4),
  d = sample(letters, 4)
)

df %>% setNames(names)
```

# Mutate and Summarise multiple columns 

This is well summarised [here](https://dplyr.tidyverse.org/reference/summarise_all.html){target="_blank"}, but a few examples are below. When using either `mutate_at()` or `summarise_at` it's important to include the "vars(), funs()" format. 

```{r} 
mtcars %>% 
  group_by(cyl) %>%
  summarise_at(vars(disp, drat, mpg), funs(median, mean))
```

The [helper functions](https://dplyr.tidyverse.org/reference/select_helpers.html){target="_blank"} for `select()` are also useful for selecting variables. Though note that when using helpers such as `contains()` that you can only include one string. For instance, this will work.

```{r}
mtcars %>% 
  summarise_at(vars(contains("ar")), funs(mean))
```

But this won't
```{r}
mtcars %>%
  summarise_at(vars(contains("ar|mp")), funs(mean))
```

If you want to match across multiple strings, the `matches()` function will do the trick. 

```{r}
mtcars %>%
  summarise_at(vars(matches("ar|mp")), funs(mean))
```

# Mutating multiple date formats within the same column

I was recently dealing with several large datasets that contain multiple date formats. I had been trying to set the dates as `as.POSIXct` formats, and it wasn't until trying to use the `difftime` function that several years were in two digit, rather than four digit format. The problem is that when specifying the date format, a two digit year pads itself with two extra zeros.

```{r}
df <- tibble(
  dates = c("30/05/2017 07:20", "19/6/17 13:47")
)

df %>% mutate(try_date = as.POSIXct(dates, tz = "", format = "%d/%m/%Y %H:%M"))
```

To get around this, we can use the `lubridate` package to solve our issues. In this case, I'm splitting out my dates and times before gluing them back together. the `dmy()` function automatically converts the `%y` into `%Y`.  

```{r, warning = FALSE}
df <- tibble(
  dates = c("30/05/2017 07:20", "19/6/17 13:47")
)

df %>% 
  mutate(working_date = lubridate::dmy(gsub("\\ .*", "", dates)),
         hour = gsub(".*\\ ", "", dates),
         final_date = as.POSIXct(glue("{working_date} {hour}"), tz="", format = "%Y-%m-%d %H:%M"))
```

# Multiple left_joins using dplyr

It's always possible to use multiple `left_join` functions, but the easiest way to do merge multiple data sets together may be to put everything into a list and then use the `Reduce` function. I had used `map` to work over a lot of data, so everything was in a list. I then took the data I wanted to use as my base and concatenated it to the list. 

```
tmp <- c(list(df), original_list)
```

Then, using dplyr commands was able to join all of the data. In this case, my original list had 30 separate dataframes.

```
mass_df <- tmp %>% Reduce(function(df1, df2), left_join(df1, df2), .)
```
The `left_join` command can be further defined to specify what we're joining by, or to select only specific columns that will be joined. 
```
# using "matches" to pull out specific variables
mass_df <- tmp %>% Reduce(function(df1, df2), left_join(df1, select(df2, matches("avar|bvar"))), .)

# specifying what the join is by
mass_df <- tmp %>% Reduce(function(df1, df2), left_join(df1, df2, by = "index"), .)
```
