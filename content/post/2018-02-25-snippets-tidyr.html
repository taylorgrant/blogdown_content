---
title: 'Snippets: tidy data'
author: ''
date: '2019-11-16'
slug: snippets-tidyr
categories:
  - R 
tags:
  - tidyr
summary: "These commands are relevant for tidying dataframes - to rearrange data and change the structure of the data for easier use."
output:
  blogdown::html_page:
    toc: true
thumbnailImagePosition: left
thumbnailImage: https://res.cloudinary.com/dn83gtg0l/image/upload/v1548271167/snippets.jpg
---


<div id="TOC">
<ul>
<li><a href="#pivoting">pivoting</a><ul>
<li><a href="#pivot_longer">pivot_longer()</a><ul>
<li><a href="#string-data-in-column-names">String data in column names</a></li>
<li><a href="#numeric-data-in-column-names">Numeric data in column names</a></li>
<li><a href="#many-variables-in-column-names">Many variables in column names</a></li>
<li><a href="#multiple-observations-per-row">Multiple observations per row</a></li>
</ul></li>
<li><a href="#pivot_wider">pivot_wider()</a><ul>
<li><a href="#aggregation">Aggregation</a></li>
<li><a href="#generate-column-name-from-multiple-variables">Generate column name from multiple variables</a></li>
<li><a href="#tidy-census-data">Tidy Census data</a></li>
<li><a href="#contact-list">Contact List</a></li>
</ul></li>
</ul></li>
<li><a href="#longer-then-wider">Longer, then Wider</a><ul>
<li><a href="#world-bank-data">World Bank data</a></li>
<li><a href="#multiple-choice-data">Multiple Choice data</a></li>
</ul></li>
<li><a href="#spread">spread()</a></li>
<li><a href="#gather">gather()</a></li>
<li><a href="#separate">separate()</a></li>
<li><a href="#unite">unite()</a></li>
</ul>
</div>

<p>Snippet files are periodically updated with how-to’s for data wrangling. These commands are relevant for tidying dataframes - to rearrange data and change the structure of the data for easier use.</p>
<div id="pivoting" class="section level1">
<h1>pivoting</h1>
<p><code>gather</code> and <code>spread</code> are being replaced by the <code>pivot</code> function. How it works…</p>
<div id="pivot_longer" class="section level2">
<h2>pivot_longer()</h2>
<div id="string-data-in-column-names" class="section level3">
<h3>String data in column names</h3>
<p>This feels very much like the old <code>gather()</code> function.</p>
<pre class="r"><code>head(relig_income)</code></pre>
<pre><code>## # A tibble: 6 x 11
##   religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`
##   &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1 Agnostic      27        34        60        81        76       137        122
## 2 Atheist       12        27        37        52        35        70         73
## 3 Buddhist      27        21        30        34        33        58         62
## 4 Catholic     418       617       732       670       638      1116        949
## 5 Don’t k…      15        14        15        11        10        35         21
## 6 Evangel…     575       869      1064       982       881      1486        949
## # … with 3 more variables: `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;, `Don&#39;t
## #   know/refused` &lt;dbl&gt;</code></pre>
<pre class="r"><code>relig_income %&gt;%
  pivot_longer(-religion, names_to = &quot;income&quot;, values_to = &quot;count&quot;)</code></pre>
<pre><code>## # A tibble: 180 x 3
##    religion income             count
##    &lt;chr&gt;    &lt;chr&gt;              &lt;dbl&gt;
##  1 Agnostic &lt;$10k                 27
##  2 Agnostic $10-20k               34
##  3 Agnostic $20-30k               60
##  4 Agnostic $30-40k               81
##  5 Agnostic $40-50k               76
##  6 Agnostic $50-75k              137
##  7 Agnostic $75-100k             122
##  8 Agnostic $100-150k            109
##  9 Agnostic &gt;150k                 84
## 10 Agnostic Don&#39;t know/refused    96
## # … with 170 more rows</code></pre>
</div>
<div id="numeric-data-in-column-names" class="section level3">
<h3>Numeric data in column names</h3>
<p>Now, here’s where you can start to see the power of the function. We grab the columns with a select helper, give it a name, and then the <code>names_prefix</code> identifies what to drop from the new variable. And we can automatically drop NAs. Note that on the first run, “week” is a string; we can change the format in the pivot command as well.</p>
<pre class="r"><code>head(billboard)</code></pre>
<pre><code>## # A tibble: 6 x 79
##   artist track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8
##   &lt;chr&gt;  &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 2 Pac  Baby… 2000-02-26      87    82    72    77    87    94    99    NA
## 2 2Ge+h… The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA
## 3 3 Doo… Kryp… 2000-04-08      81    70    68    67    66    57    54    53
## 4 3 Doo… Loser 2000-10-21      76    76    72    69    67    65    55    59
## 5 504 B… Wobb… 2000-04-15      57    34    25    17    17    31    36    49
## 6 98^0   Give… 2000-08-19      51    39    34    26    26    19     2     2
## # … with 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,
## #   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,
## #   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,
## #   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,
## #   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,
## #   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;,
## #   wk43 &lt;dbl&gt;, wk44 &lt;dbl&gt;, wk45 &lt;dbl&gt;, wk46 &lt;dbl&gt;, wk47 &lt;dbl&gt;, wk48 &lt;dbl&gt;,
## #   wk49 &lt;dbl&gt;, wk50 &lt;dbl&gt;, wk51 &lt;dbl&gt;, wk52 &lt;dbl&gt;, wk53 &lt;dbl&gt;, wk54 &lt;dbl&gt;,
## #   wk55 &lt;dbl&gt;, wk56 &lt;dbl&gt;, wk57 &lt;dbl&gt;, wk58 &lt;dbl&gt;, wk59 &lt;dbl&gt;, wk60 &lt;dbl&gt;,
## #   wk61 &lt;dbl&gt;, wk62 &lt;dbl&gt;, wk63 &lt;dbl&gt;, wk64 &lt;dbl&gt;, wk65 &lt;dbl&gt;, wk66 &lt;lgl&gt;,
## #   wk67 &lt;lgl&gt;, wk68 &lt;lgl&gt;, wk69 &lt;lgl&gt;, wk70 &lt;lgl&gt;, wk71 &lt;lgl&gt;, wk72 &lt;lgl&gt;,
## #   wk73 &lt;lgl&gt;, wk74 &lt;lgl&gt;, wk75 &lt;lgl&gt;, wk76 &lt;lgl&gt;</code></pre>
<pre class="r"><code>billboard %&gt;%
  pivot_longer(
    cols = starts_with(&quot;wk&quot;),
    names_to = &quot;week&quot;,
    names_prefix = &quot;wk&quot;,
    values_to = &quot;rank&quot;,
    values_drop_na = TRUE
  )</code></pre>
<pre><code>## # A tibble: 5,307 x 5
##    artist  track                   date.entered week   rank
##    &lt;chr&gt;   &lt;chr&gt;                   &lt;date&gt;       &lt;chr&gt; &lt;dbl&gt;
##  1 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   1        87
##  2 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   2        82
##  3 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   3        72
##  4 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   4        77
##  5 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   5        87
##  6 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   6        94
##  7 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26   7        99
##  8 2Ge+her The Hardest Part Of ... 2000-09-02   1        91
##  9 2Ge+her The Hardest Part Of ... 2000-09-02   2        87
## 10 2Ge+her The Hardest Part Of ... 2000-09-02   3        92
## # … with 5,297 more rows</code></pre>
<pre class="r"><code>billboard %&gt;% 
  pivot_longer(
    cols = starts_with(&quot;wk&quot;), 
    names_to = &quot;week&quot;, 
    names_prefix = &quot;wk&quot;,
    names_ptypes = list(week = integer()),
    values_to = &quot;rank&quot;,
    values_drop_na = TRUE,
  )</code></pre>
<pre><code>## # A tibble: 5,307 x 5
##    artist  track                   date.entered  week  rank
##    &lt;chr&gt;   &lt;chr&gt;                   &lt;date&gt;       &lt;int&gt; &lt;dbl&gt;
##  1 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       1    87
##  2 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       2    82
##  3 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       3    72
##  4 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       4    77
##  5 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       5    87
##  6 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       6    94
##  7 2 Pac   Baby Don&#39;t Cry (Keep... 2000-02-26       7    99
##  8 2Ge+her The Hardest Part Of ... 2000-09-02       1    91
##  9 2Ge+her The Hardest Part Of ... 2000-09-02       2    87
## 10 2Ge+her The Hardest Part Of ... 2000-09-02       3    92
## # … with 5,297 more rows</code></pre>
</div>
<div id="many-variables-in-column-names" class="section level3">
<h3>Many variables in column names</h3>
<p>Even more complex, here we’re taking multiple columns, gathering them, and then creating three new columns of data. The <code>names_pattern</code> uses the same specification as <code>separate()</code>, in this case regex to split out the data. To understand it, run it first, without the multiple columns, then again with it.</p>
<pre class="r"><code>head(who)</code></pre>
<pre><code>## # A tibble: 6 x 60
##   country iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544
##   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;int&gt;       &lt;int&gt;        &lt;int&gt;        &lt;int&gt;        &lt;int&gt;
## 1 Afghan… AF    AFG    1980          NA           NA           NA           NA
## 2 Afghan… AF    AFG    1981          NA           NA           NA           NA
## 3 Afghan… AF    AFG    1982          NA           NA           NA           NA
## 4 Afghan… AF    AFG    1983          NA           NA           NA           NA
## 5 Afghan… AF    AFG    1984          NA           NA           NA           NA
## 6 Afghan… AF    AFG    1985          NA           NA           NA           NA
## # … with 52 more variables: new_sp_m4554 &lt;int&gt;, new_sp_m5564 &lt;int&gt;,
## #   new_sp_m65 &lt;int&gt;, new_sp_f014 &lt;int&gt;, new_sp_f1524 &lt;int&gt;,
## #   new_sp_f2534 &lt;int&gt;, new_sp_f3544 &lt;int&gt;, new_sp_f4554 &lt;int&gt;,
## #   new_sp_f5564 &lt;int&gt;, new_sp_f65 &lt;int&gt;, new_sn_m014 &lt;int&gt;,
## #   new_sn_m1524 &lt;int&gt;, new_sn_m2534 &lt;int&gt;, new_sn_m3544 &lt;int&gt;,
## #   new_sn_m4554 &lt;int&gt;, new_sn_m5564 &lt;int&gt;, new_sn_m65 &lt;int&gt;,
## #   new_sn_f014 &lt;int&gt;, new_sn_f1524 &lt;int&gt;, new_sn_f2534 &lt;int&gt;,
## #   new_sn_f3544 &lt;int&gt;, new_sn_f4554 &lt;int&gt;, new_sn_f5564 &lt;int&gt;,
## #   new_sn_f65 &lt;int&gt;, new_ep_m014 &lt;int&gt;, new_ep_m1524 &lt;int&gt;,
## #   new_ep_m2534 &lt;int&gt;, new_ep_m3544 &lt;int&gt;, new_ep_m4554 &lt;int&gt;,
## #   new_ep_m5564 &lt;int&gt;, new_ep_m65 &lt;int&gt;, new_ep_f014 &lt;int&gt;,
## #   new_ep_f1524 &lt;int&gt;, new_ep_f2534 &lt;int&gt;, new_ep_f3544 &lt;int&gt;,
## #   new_ep_f4554 &lt;int&gt;, new_ep_f5564 &lt;int&gt;, new_ep_f65 &lt;int&gt;,
## #   newrel_m014 &lt;int&gt;, newrel_m1524 &lt;int&gt;, newrel_m2534 &lt;int&gt;,
## #   newrel_m3544 &lt;int&gt;, newrel_m4554 &lt;int&gt;, newrel_m5564 &lt;int&gt;,
## #   newrel_m65 &lt;int&gt;, newrel_f014 &lt;int&gt;, newrel_f1524 &lt;int&gt;,
## #   newrel_f2534 &lt;int&gt;, newrel_f3544 &lt;int&gt;, newrel_f4554 &lt;int&gt;,
## #   newrel_f5564 &lt;int&gt;, newrel_f65 &lt;int&gt;</code></pre>
<pre class="r"><code>who %&gt;% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  # names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;),
  # names_pattern = &quot;new_?(.*)_(.)(.*)&quot;,
  values_to = &quot;count&quot;
) %&gt;% sample_n(5)</code></pre>
<pre><code>## # A tibble: 5 x 6
##   country    iso2  iso3   year name         count
##   &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;        &lt;int&gt;
## 1 Latvia     LV    LVA    1988 new_sp_f65      NA
## 2 Brazil     BR    BRA    2006 new_sn_f014    787
## 3 Niue       NU    NIU    1989 newrel_f4554    NA
## 4 Kyrgyzstan KG    KGZ    1988 new_ep_f3544    NA
## 5 Libya      LY    LBY    1984 newrel_m5564    NA</code></pre>
<pre class="r"><code>who %&gt;% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;),
  names_pattern = &quot;new_?(.*)_(.)(.*)&quot;,
  values_to = &quot;count&quot;
) %&gt;% sample_n(5)</code></pre>
<pre><code>## # A tibble: 5 x 8
##   country          iso2  iso3   year diagnosis gender age   count
##   &lt;chr&gt;            &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;     &lt;chr&gt;  &lt;chr&gt; &lt;int&gt;
## 1 Papua New Guinea PG    PNG    1993 sp        f      4554     NA
## 2 Anguilla         AI    AIA    2008 rel       f      3544     NA
## 3 French Polynesia PF    PYF    1994 ep        m      014      NA
## 4 Mozambique       MZ    MOZ    1981 rel       m      2534     NA
## 5 Estonia          EE    EST    1987 ep        m      3544     NA</code></pre>
<p>To take it even further, we can identify these newly created variables as factors and define them within the same function using the <code>names_ptypes</code> command.</p>
<pre class="r"><code>who %&gt;% pivot_longer(
  cols = new_sp_m014:newrel_f65,
  names_to = c(&quot;diagnosis&quot;, &quot;gender&quot;, &quot;age&quot;), 
  names_pattern = &quot;new_?(.*)_(.)(.*)&quot;,
  names_ptypes = list(
    gender = factor(levels = c(&quot;f&quot;, &quot;m&quot;)),
    age = factor(
      levels = c(&quot;014&quot;, &quot;1524&quot;, &quot;2534&quot;, &quot;3544&quot;, &quot;4554&quot;, &quot;5564&quot;, &quot;65&quot;), 
      ordered = TRUE
    )
  ),
  values_to = &quot;count&quot;,
)</code></pre>
<pre><code>## # A tibble: 405,440 x 8
##    country     iso2  iso3   year diagnosis gender age   count
##    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt;     &lt;fct&gt;  &lt;ord&gt; &lt;int&gt;
##  1 Afghanistan AF    AFG    1980 sp        m      014      NA
##  2 Afghanistan AF    AFG    1980 sp        m      1524     NA
##  3 Afghanistan AF    AFG    1980 sp        m      2534     NA
##  4 Afghanistan AF    AFG    1980 sp        m      3544     NA
##  5 Afghanistan AF    AFG    1980 sp        m      4554     NA
##  6 Afghanistan AF    AFG    1980 sp        m      5564     NA
##  7 Afghanistan AF    AFG    1980 sp        m      65       NA
##  8 Afghanistan AF    AFG    1980 sp        f      014      NA
##  9 Afghanistan AF    AFG    1980 sp        f      1524     NA
## 10 Afghanistan AF    AFG    1980 sp        f      2534     NA
## # … with 405,430 more rows</code></pre>
</div>
<div id="multiple-observations-per-row" class="section level3">
<h3>Multiple observations per row</h3>
<p>In the below, each row has two individuals, or sometimes an NA for the second. This gathers all rows except family, and the use “.value” in the <code>names_to</code> command specifies that part of the column name should be a new variable.</p>
<pre class="r"><code>family &lt;- tribble(
  ~family,  ~dob_child1,  ~dob_child2, ~gender_child1, ~gender_child2,
       1L, &quot;1998-11-26&quot;, &quot;2000-01-29&quot;,             1L,             2L,
       2L, &quot;1996-06-22&quot;,           NA,             2L,             NA,
       3L, &quot;2002-07-11&quot;, &quot;2004-04-05&quot;,             2L,             2L,
       4L, &quot;2004-10-10&quot;, &quot;2009-08-27&quot;,             1L,             1L,
       5L, &quot;2000-12-05&quot;, &quot;2005-02-28&quot;,             2L,             1L,
) %&gt;% mutate_at(vars(starts_with(&quot;dob&quot;)), parse_date)
family</code></pre>
<pre><code>## # A tibble: 5 x 5
##   family dob_child1 dob_child2 gender_child1 gender_child2
##    &lt;int&gt; &lt;date&gt;     &lt;date&gt;             &lt;int&gt;         &lt;int&gt;
## 1      1 1998-11-26 2000-01-29             1             2
## 2      2 1996-06-22 NA                     2            NA
## 3      3 2002-07-11 2004-04-05             2             2
## 4      4 2004-10-10 2009-08-27             1             1
## 5      5 2000-12-05 2005-02-28             2             1</code></pre>
<pre class="r"><code>family %&gt;% 
  pivot_longer(
    -family, 
    names_to = c(&quot;.value&quot;, &quot;child&quot;), 
    names_sep = &quot;_&quot;, 
    values_drop_na = TRUE
  )</code></pre>
<pre><code>## # A tibble: 9 x 4
##   family child  dob        gender
##    &lt;int&gt; &lt;chr&gt;  &lt;date&gt;      &lt;int&gt;
## 1      1 child1 1998-11-26      1
## 2      1 child2 2000-01-29      2
## 3      2 child1 1996-06-22      2
## 4      3 child1 2002-07-11      2
## 5      3 child2 2004-04-05      2
## 6      4 child1 2004-10-10      1
## 7      4 child2 2009-08-27      1
## 8      5 child1 2000-12-05      2
## 9      5 child2 2005-02-28      1</code></pre>
<p>Another example of using the “.value” is in the following. .value captures the new variable name and “time” is the numeric identifier.</p>
<pre class="r"><code>pnl &lt;- tibble(
  x = 1:4,
  a = c(1, 1,0, 0),
  b = c(0, 1, 1, 1),
  y1 = rnorm(4),
  y2 = rnorm(4),
  z1 = rep(3, 4),
  z2 = rep(-2, 4),
)
pnl</code></pre>
<pre><code>## # A tibble: 4 x 7
##       x     a     b      y1     y2    z1    z2
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     1     0 -0.418  -0.597     3    -2
## 2     2     1     1  0.394   0.536     3    -2
## 3     3     0     1  0.0897  0.983     3    -2
## 4     4     0     1  1.06    1.23      3    -2</code></pre>
<pre class="r"><code>pnl %&gt;% 
  pivot_longer(
    -c(x, a, b), 
    names_to = c(&quot;.value&quot;, &quot;time&quot;), 
    names_pattern = &quot;(.)(.)&quot;
  )</code></pre>
<pre><code>## # A tibble: 8 x 6
##       x     a     b time        y     z
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1     1     1     0 1     -0.418      3
## 2     1     1     0 2     -0.597     -2
## 3     2     1     1 1      0.394      3
## 4     2     1     1 2      0.536     -2
## 5     3     0     1 1      0.0897     3
## 6     3     0     1 2      0.983     -2
## 7     4     0     1 1      1.06       3
## 8     4     0     1 2      1.23      -2</code></pre>
</div>
</div>
<div id="pivot_wider" class="section level2">
<h2>pivot_wider()</h2>
<p>Data capturing anytime a fish passes through a station. A row is only added if a fish was seen, so often times there will be NAs. If we widen the data so that each station is a column, the NAs are apparent. The NAs can be filled within the function using the <code>values_fill</code> command.</p>
<pre class="r"><code>fish_encounters</code></pre>
<pre><code>## # A tibble: 114 x 3
##    fish  station  seen
##    &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;
##  1 4842  Release     1
##  2 4842  I80_1       1
##  3 4842  Lisbon      1
##  4 4842  Rstr        1
##  5 4842  Base_TD     1
##  6 4842  BCE         1
##  7 4842  BCW         1
##  8 4842  BCE2        1
##  9 4842  BCW2        1
## 10 4842  MAE         1
## # … with 104 more rows</code></pre>
<pre class="r"><code>fish_encounters %&gt;% pivot_wider(
  names_from = station, 
  values_from = seen,
  # values_fill = list(seen = 0)
) %&gt;% head()</code></pre>
<pre><code>## # A tibble: 6 x 12
##   fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW
##   &lt;fct&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1 4842        1     1      1     1       1     1     1     1     1     1     1
## 2 4843        1     1      1     1       1     1     1     1     1     1     1
## 3 4844        1     1      1     1       1     1     1     1     1     1     1
## 4 4845        1     1      1     1       1    NA    NA    NA    NA    NA    NA
## 5 4847        1     1      1    NA      NA    NA    NA    NA    NA    NA    NA
## 6 4848        1     1      1     1      NA    NA    NA    NA    NA    NA    NA</code></pre>
<pre class="r"><code>fish_encounters %&gt;% pivot_wider(
  names_from = station, 
  values_from = seen,
  values_fill = list(seen = 0)
) %&gt;% head()</code></pre>
<pre><code>## # A tibble: 6 x 12
##   fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW
##   &lt;fct&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1 4842        1     1      1     1       1     1     1     1     1     1     1
## 2 4843        1     1      1     1       1     1     1     1     1     1     1
## 3 4844        1     1      1     1       1     1     1     1     1     1     1
## 4 4845        1     1      1     1       1     0     0     0     0     0     0
## 5 4847        1     1      1     0       0     0     0     0     0     0     0
## 6 4848        1     1      1     1       0     0     0     0     0     0     0</code></pre>
<div id="aggregation" class="section level3">
<h3>Aggregation</h3>
<p>This is actually sort of bonkers. We can spread data and aggregate it, all at the same time. The warpbreaks dataset captures 9 experiments for 2 different types of wool and 3 levels of tension. There is no unique way of spreading the data.</p>
<pre class="r"><code>warpbreaks &lt;- warpbreaks %&gt;% as_tibble() %&gt;% select(wool, tension, breaks)
warpbreaks</code></pre>
<pre><code>## # A tibble: 54 x 3
##    wool  tension breaks
##    &lt;fct&gt; &lt;fct&gt;    &lt;dbl&gt;
##  1 A     L           26
##  2 A     L           30
##  3 A     L           54
##  4 A     L           25
##  5 A     L           70
##  6 A     L           52
##  7 A     L           51
##  8 A     L           26
##  9 A     L           67
## 10 A     M           18
## # … with 44 more rows</code></pre>
<pre class="r"><code>warpbreaks %&gt;% count(wool, tension)</code></pre>
<pre><code>## # A tibble: 6 x 3
##   wool  tension     n
##   &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;
## 1 A     L           9
## 2 A     M           9
## 3 A     H           9
## 4 B     L           9
## 5 B     M           9
## 6 B     H           9</code></pre>
<pre class="r"><code>warpbreaks %&gt;% pivot_wider(names_from = wool, values_from = breaks)</code></pre>
<pre><code>## Warning: Values in `breaks` are not uniquely identified; output will contain list-cols.
## * Use `values_fn = list(breaks = list)` to suppress this warning.
## * Use `values_fn = list(breaks = length)` to identify where the duplicates arise
## * Use `values_fn = list(breaks = summary_fun)` to summarise duplicates</code></pre>
<pre><code>## # A tibble: 3 x 3
##   tension           A           B
##   &lt;fct&gt;   &lt;list&lt;dbl&gt;&gt; &lt;list&lt;dbl&gt;&gt;
## 1 L               [9]         [9]
## 2 M               [9]         [9]
## 3 H               [9]         [9]</code></pre>
<p>But we can use <code>pivot_wider()</code> to spread the data and then to aggregate each wool and tension to the average.</p>
<pre class="r"><code>warpbreaks %&gt;% 
  pivot_wider(
    names_from = wool, 
    values_from = breaks,
    values_fn = list(breaks = mean)
  )</code></pre>
<pre><code>## # A tibble: 3 x 3
##   tension     A     B
##   &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt;
## 1 L        44.6  28.2
## 2 M        24    28.8
## 3 H        24.6  18.8</code></pre>
</div>
<div id="generate-column-name-from-multiple-variables" class="section level3">
<h3>Generate column name from multiple variables</h3>
<p>Data with a country and production levels of specific products. What if wanted a column for each product <em>and</em> country?</p>
<pre class="r"><code>production &lt;- expand_grid(
    product = c(&quot;A&quot;, &quot;B&quot;), 
    country = c(&quot;AI&quot;, &quot;EI&quot;), 
    year = 2000:2014
  ) %&gt;%
  filter((product == &quot;A&quot; &amp; country == &quot;AI&quot;) | product == &quot;B&quot;) %&gt;% 
  mutate(production = rnorm(nrow(.)))
production</code></pre>
<pre><code>## # A tibble: 45 x 4
##    product country  year production
##    &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;
##  1 A       AI       2000      0.709
##  2 A       AI       2001     -2.30 
##  3 A       AI       2002     -0.247
##  4 A       AI       2003     -0.768
##  5 A       AI       2004     -0.724
##  6 A       AI       2005      1.64 
##  7 A       AI       2006      1.98 
##  8 A       AI       2007      0.603
##  9 A       AI       2008      2.37 
## 10 A       AI       2009     -1.10 
## # … with 35 more rows</code></pre>
<p>By specifying multiple <code>names_from</code> we can unite them into single columns.</p>
<pre class="r"><code>production %&gt;% pivot_wider(
  names_from = c(product, country), 
  values_from = production
)</code></pre>
<pre><code>## # A tibble: 15 x 4
##     year   A_AI   B_AI   B_EI
##    &lt;int&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1  2000  0.709 -0.271  0.165
##  2  2001 -2.30  -1.30   0.167
##  3  2002 -0.247 -0.294  1.01 
##  4  2003 -0.768 -0.181  0.604
##  5  2004 -0.724 -1.95   1.45 
##  6  2005  1.64  -0.499  0.361
##  7  2006  1.98   0.970  0.119
##  8  2007  0.603 -0.234  0.364
##  9  2008  2.37   0.422  0.562
## 10  2009 -1.10  -0.969 -2.06 
## 11  2010  0.513 -0.503  0.513
## 12  2011  1.70  -0.964 -0.936
## 13  2012  0.177  1.65  -2.52 
## 14  2013  1.48   0.341 -0.554
## 15  2014 -1.19  -0.959 -0.496</code></pre>
</div>
<div id="tidy-census-data" class="section level3">
<h3>Tidy Census data</h3>
<p>This looks very much like a standard use case of <code>spread()</code>.</p>
<pre class="r"><code>us_rent_income</code></pre>
<pre><code>## # A tibble: 104 x 5
##    GEOID NAME       variable estimate   moe
##    &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;
##  1 01    Alabama    income      24476   136
##  2 01    Alabama    rent          747     3
##  3 02    Alaska     income      32940   508
##  4 02    Alaska     rent         1200    13
##  5 04    Arizona    income      27517   148
##  6 04    Arizona    rent          972     4
##  7 05    Arkansas   income      23789   165
##  8 05    Arkansas   rent          709     5
##  9 06    California income      29454   109
## 10 06    California rent         1358     3
## # … with 94 more rows</code></pre>
<pre class="r"><code>us_rent_income %&gt;% 
  pivot_wider(names_from = variable, values_from = c(estimate, moe))</code></pre>
<pre><code>## # A tibble: 52 x 6
##    GEOID NAME                 estimate_income estimate_rent moe_income moe_rent
##    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;
##  1 01    Alabama                        24476           747        136        3
##  2 02    Alaska                         32940          1200        508       13
##  3 04    Arizona                        27517           972        148        4
##  4 05    Arkansas                       23789           709        165        5
##  5 06    California                     29454          1358        109        3
##  6 08    Colorado                       32401          1125        109        5
##  7 09    Connecticut                    35326          1123        195        5
##  8 10    Delaware                       31560          1076        247       10
##  9 11    District of Columbia           43198          1424        681       17
## 10 12    Florida                        25952          1077         70        3
## # … with 42 more rows</code></pre>
</div>
<div id="contact-list" class="section level3">
<h3>Contact List</h3>
<pre class="r"><code>contacts &lt;- tribble(
  ~field, ~value,
  &quot;name&quot;, &quot;Jiena McLellan&quot;,
  &quot;company&quot;, &quot;Toyota&quot;, 
  &quot;name&quot;, &quot;John Smith&quot;, 
  &quot;company&quot;, &quot;google&quot;, 
  &quot;email&quot;, &quot;john@google.com&quot;,
  &quot;name&quot;, &quot;Huxley Ratcliffe&quot;
)
contacts</code></pre>
<pre><code>## # A tibble: 6 x 2
##   field   value           
##   &lt;chr&gt;   &lt;chr&gt;           
## 1 name    Jiena McLellan  
## 2 company Toyota          
## 3 name    John Smith      
## 4 company google          
## 5 email   john@google.com 
## 6 name    Huxley Ratcliffe</code></pre>
<p>There is no unique identifier for each person, so we have to create one. And from there we can then spread it all out.</p>
<pre class="r"><code>contacts &lt;- contacts %&gt;% 
  mutate(
    person_id = cumsum(field == &quot;name&quot;)
  )
contacts</code></pre>
<pre><code>## # A tibble: 6 x 3
##   field   value            person_id
##   &lt;chr&gt;   &lt;chr&gt;                &lt;int&gt;
## 1 name    Jiena McLellan           1
## 2 company Toyota                   1
## 3 name    John Smith               2
## 4 company google                   2
## 5 email   john@google.com          2
## 6 name    Huxley Ratcliffe         3</code></pre>
<pre class="r"><code>contacts %&gt;% 
  pivot_wider(names_from = field, values_from = value)</code></pre>
<pre><code>## # A tibble: 3 x 4
##   person_id name             company email          
##       &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;   &lt;chr&gt;          
## 1         1 Jiena McLellan   Toyota  &lt;NA&gt;           
## 2         2 John Smith       google  john@google.com
## 3         3 Huxley Ratcliffe &lt;NA&gt;    &lt;NA&gt;</code></pre>
</div>
</div>
</div>
<div id="longer-then-wider" class="section level1">
<h1>Longer, then Wider</h1>
<div id="world-bank-data" class="section level3">
<h3>World Bank data</h3>
<p>The goal is to produce a tidy dataset where each variable is a column.</p>
<pre class="r"><code>world_bank_pop</code></pre>
<pre><code>## # A tibble: 1,056 x 20
##    country indicator `2000` `2001` `2002` `2003`  `2004`  `2005`   `2006`
##    &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;
##  1 ABW     SP.URB.T… 4.24e4 4.30e4 4.37e4 4.42e4 4.47e+4 4.49e+4  4.49e+4
##  2 ABW     SP.URB.G… 1.18e0 1.41e0 1.43e0 1.31e0 9.51e-1 4.91e-1 -1.78e-2
##  3 ABW     SP.POP.T… 9.09e4 9.29e4 9.50e4 9.70e4 9.87e+4 1.00e+5  1.01e+5
##  4 ABW     SP.POP.G… 2.06e0 2.23e0 2.23e0 2.11e0 1.76e+0 1.30e+0  7.98e-1
##  5 AFG     SP.URB.T… 4.44e6 4.65e6 4.89e6 5.16e6 5.43e+6 5.69e+6  5.93e+6
##  6 AFG     SP.URB.G… 3.91e0 4.66e0 5.13e0 5.23e0 5.12e+0 4.77e+0  4.12e+0
##  7 AFG     SP.POP.T… 2.01e7 2.10e7 2.20e7 2.31e7 2.41e+7 2.51e+7  2.59e+7
##  8 AFG     SP.POP.G… 3.49e0 4.25e0 4.72e0 4.82e0 4.47e+0 3.87e+0  3.23e+0
##  9 AGO     SP.URB.T… 8.23e6 8.71e6 9.22e6 9.77e6 1.03e+7 1.09e+7  1.15e+7
## 10 AGO     SP.URB.G… 5.44e0 5.59e0 5.70e0 5.76e0 5.75e+0 5.69e+0  4.92e+0
## # … with 1,046 more rows, and 11 more variables: `2007` &lt;dbl&gt;, `2008` &lt;dbl&gt;,
## #   `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;, `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, `2013` &lt;dbl&gt;,
## #   `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;, `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;</code></pre>
<p>First, use <code>pivot_longer()</code> to start.</p>
<pre class="r"><code>pop2 &lt;- world_bank_pop %&gt;% 
  pivot_longer(`2000`:`2017`, names_to = &quot;year&quot;, values_to = &quot;value&quot;)
pop2</code></pre>
<pre><code>## # A tibble: 19,008 x 4
##    country indicator   year  value
##    &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt; &lt;dbl&gt;
##  1 ABW     SP.URB.TOTL 2000  42444
##  2 ABW     SP.URB.TOTL 2001  43048
##  3 ABW     SP.URB.TOTL 2002  43670
##  4 ABW     SP.URB.TOTL 2003  44246
##  5 ABW     SP.URB.TOTL 2004  44669
##  6 ABW     SP.URB.TOTL 2005  44889
##  7 ABW     SP.URB.TOTL 2006  44881
##  8 ABW     SP.URB.TOTL 2007  44686
##  9 ABW     SP.URB.TOTL 2008  44375
## 10 ABW     SP.URB.TOTL 2009  44052
## # … with 18,998 more rows</code></pre>
<p>But we are still left with multiple “indicator” variables per country. So now we have to separate.</p>
<pre class="r"><code>pop3 &lt;- pop2 %&gt;% 
  separate(indicator, c(NA, &quot;area&quot;, &quot;variable&quot;))
pop3</code></pre>
<pre><code>## # A tibble: 19,008 x 5
##    country area  variable year  value
##    &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; &lt;dbl&gt;
##  1 ABW     URB   TOTL     2000  42444
##  2 ABW     URB   TOTL     2001  43048
##  3 ABW     URB   TOTL     2002  43670
##  4 ABW     URB   TOTL     2003  44246
##  5 ABW     URB   TOTL     2004  44669
##  6 ABW     URB   TOTL     2005  44889
##  7 ABW     URB   TOTL     2006  44881
##  8 ABW     URB   TOTL     2007  44686
##  9 ABW     URB   TOTL     2008  44375
## 10 ABW     URB   TOTL     2009  44052
## # … with 18,998 more rows</code></pre>
<p>Now we can widen the data.</p>
<pre class="r"><code>pop3 %&gt;% 
  pivot_wider(names_from = variable, values_from = value)</code></pre>
<pre><code>## # A tibble: 9,504 x 5
##    country area  year   TOTL    GROW
##    &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt;
##  1 ABW     URB   2000  42444  1.18  
##  2 ABW     URB   2001  43048  1.41  
##  3 ABW     URB   2002  43670  1.43  
##  4 ABW     URB   2003  44246  1.31  
##  5 ABW     URB   2004  44669  0.951 
##  6 ABW     URB   2005  44889  0.491 
##  7 ABW     URB   2006  44881 -0.0178
##  8 ABW     URB   2007  44686 -0.435 
##  9 ABW     URB   2008  44375 -0.698 
## 10 ABW     URB   2009  44052 -0.731 
## # … with 9,494 more rows</code></pre>
</div>
<div id="multiple-choice-data" class="section level3">
<h3>Multiple Choice data</h3>
<pre class="r"><code>multi &lt;- tribble(
  ~id, ~choice1, ~choice2, ~choice3,
  1, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;,
  2, &quot;C&quot;, &quot;B&quot;,  NA,
  3, &quot;D&quot;,  NA,  NA,
  4, &quot;B&quot;, &quot;D&quot;,  NA
)
multi</code></pre>
<pre><code>## # A tibble: 4 x 4
##      id choice1 choice2 choice3
##   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  
## 1     1 A       B       C      
## 2     2 C       B       &lt;NA&gt;   
## 3     3 D       &lt;NA&gt;    &lt;NA&gt;   
## 4     4 B       D       &lt;NA&gt;</code></pre>
<p>First, gather it with <code>pivot_longer()</code> dropping the NAs for people with fewere than 3 choices.</p>
<pre class="r"><code>multi2 &lt;- multi %&gt;% 
  pivot_longer(-id, values_drop_na = TRUE) %&gt;% 
  mutate(checked = TRUE)
multi2</code></pre>
<pre><code>## # A tibble: 8 x 4
##      id name    value checked
##   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt; &lt;lgl&gt;  
## 1     1 choice1 A     TRUE   
## 2     1 choice2 B     TRUE   
## 3     1 choice3 C     TRUE   
## 4     2 choice1 C     TRUE   
## 5     2 choice2 B     TRUE   
## 6     3 choice1 D     TRUE   
## 7     4 choice1 B     TRUE   
## 8     4 choice2 D     TRUE</code></pre>
<p>Then widen the data</p>
<pre class="r"><code>multi2 %&gt;% 
  pivot_wider(
    id_cols = id,
    names_from = value, 
    values_from = checked, 
    values_fill = list(checked = FALSE)
  )</code></pre>
<pre><code>## # A tibble: 4 x 5
##      id A     B     C     D    
##   &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;
## 1     1 TRUE  TRUE  TRUE  FALSE
## 2     2 FALSE TRUE  TRUE  FALSE
## 3     3 FALSE FALSE FALSE TRUE 
## 4     4 FALSE TRUE  FALSE TRUE</code></pre>
</div>
</div>
<div id="spread" class="section level1">
<h1>spread()</h1>
<p>Spread is based on the key, value pairing – the key becomes the names of the new columns and the values are row values within each new column.</p>
<pre class="r"><code>pacman::p_load(tidyverse, blogdown, glue, here)
dat &lt;- read_csv(&quot;https://raw.githubusercontent.com/garrettgman/DSR/master/data-raw/table2.csv&quot;)

dat</code></pre>
<pre><code>## # A tibble: 12 x 4
##    country      year key             value
##    &lt;chr&gt;       &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt;
##  1 Afghanistan  1999 cases             745
##  2 Afghanistan  1999 population   19987071
##  3 Afghanistan  2000 cases            2666
##  4 Afghanistan  2000 population   20595360
##  5 Brazil       1999 cases           37737
##  6 Brazil       1999 population  172006362
##  7 Brazil       2000 cases           80488
##  8 Brazil       2000 population  174504898
##  9 China        1999 cases          212258
## 10 China        1999 population 1272915272
## 11 China        2000 cases          213766
## 12 China        2000 population 1280428583</code></pre>
<pre class="r"><code>dat %&gt;% spread(key, value)</code></pre>
<pre><code>## # A tibble: 6 x 4
##   country      year  cases population
##   &lt;chr&gt;       &lt;dbl&gt;  &lt;dbl&gt;      &lt;dbl&gt;
## 1 Afghanistan  1999    745   19987071
## 2 Afghanistan  2000   2666   20595360
## 3 Brazil       1999  37737  172006362
## 4 Brazil       2000  80488  174504898
## 5 China        1999 212258 1272915272
## 6 China        2000 213766 1280428583</code></pre>
</div>
<div id="gather" class="section level1">
<h1>gather()</h1>
<p><code>gather</code> is going to work in the opposite direction. It gathers the column names, puts them in a single column, and then matches the value to each row. Note that you need to specify the columns you want to bring into the gathering.</p>
<pre class="r"><code>library(tidyverse)
dat &lt;- read_csv(&quot;https://raw.githubusercontent.com/garrettgman/DSR/master/data-raw/table4.csv&quot;)

dat</code></pre>
<pre><code>## # A tibble: 3 x 3
##   country     `1999` `2000`
##   &lt;chr&gt;        &lt;dbl&gt;  &lt;dbl&gt;
## 1 Afghanistan    745   2666
## 2 Brazil       37737  80488
## 3 China       212258 213766</code></pre>
<pre class="r"><code>dat %&gt;% gather(&quot;year&quot;, &quot;cases&quot;, 2:3)</code></pre>
<pre><code>## # A tibble: 6 x 3
##   country     year   cases
##   &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;
## 1 Afghanistan 1999     745
## 2 Brazil      1999   37737
## 3 China       1999  212258
## 4 Afghanistan 2000    2666
## 5 Brazil      2000   80488
## 6 China       2000  213766</code></pre>
<p><code>gather</code> works similar to the dplyr function <code>select</code> in that you can also use the -varname to specify which variable isn’t included.</p>
<pre class="r"><code>library(tidyverse)
dat &lt;- read_csv(&quot;https://raw.githubusercontent.com/garrettgman/DSR/master/data-raw/table4.csv&quot;)

dat %&gt;% gather(year, cases, -country)</code></pre>
<pre><code>## # A tibble: 6 x 3
##   country     year   cases
##   &lt;chr&gt;       &lt;chr&gt;  &lt;dbl&gt;
## 1 Afghanistan 1999     745
## 2 Brazil      1999   37737
## 3 China       1999  212258
## 4 Afghanistan 2000    2666
## 5 Brazil      2000   80488
## 6 China       2000  213766</code></pre>
</div>
<div id="separate" class="section level1">
<h1>separate()</h1>
<p><code>separate</code> works when a dataframe includes compound variables - for instance, age and gender demographics. <code>separate</code> works in one of two ways - first, you can pass it a regular expression to split on, but if you choose not to give it, it will default to non-alphanumeric character to split on, as below.</p>
<pre class="r"><code>df &lt;- data.frame(x = c(NA, &quot;m.14&quot;, &quot;f.20&quot;, &quot;f.45&quot;))
df %&gt;% separate(x, c(&quot;Gender&quot;, &quot;Age&quot;))</code></pre>
<pre><code>##   Gender  Age
## 1   &lt;NA&gt; &lt;NA&gt;
## 2      m   14
## 3      f   20
## 4      f   45</code></pre>
<p>Second, you can tell it how many characters in to split on. If we change our example somewhat, we can see where this might be useful.</p>
<pre class="r"><code>df &lt;- data.frame(x = c(NA, &quot;m14&quot;, &quot;f20&quot;, &quot;f45&quot;))
df %&gt;% separate(x, c(&quot;Gender&quot;, &quot;Age&quot;) , 1)</code></pre>
<pre><code>##   Gender  Age
## 1   &lt;NA&gt; &lt;NA&gt;
## 2      m   14
## 3      f   20
## 4      f   45</code></pre>
</div>
<div id="unite" class="section level1">
<h1>unite()</h1>
<p>The <code>unite</code> function is helpful in that it pulls disparate columns together into one. To see how it works, we’ll make some fake data, and then use <code>unite</code> to pull the hour, min, and second into a single variable.</p>
<pre class="r"><code>date &lt;- as.Date(&#39;2018-01-01&#39;) + 0:14
hour &lt;- sample(1:24, 15)
min &lt;- sample(1:60, 15)
second &lt;- sample(1:60, 15)
event &lt;- sample(letters, 15)
data &lt;- data.frame(date, hour, min, second, event)
data</code></pre>
<pre><code>##          date hour min second event
## 1  2018-01-01   16  49     30     h
## 2  2018-01-02   24  43     23     c
## 3  2018-01-03    8  42     29     i
## 4  2018-01-04   14  58     56     t
## 5  2018-01-05    4  31     54     e
## 6  2018-01-06   18  23     42     a
## 7  2018-01-07   21  59     57     k
## 8  2018-01-08   23  25     33     s
## 9  2018-01-09   15   2     19     x
## 10 2018-01-10    6  11     58     g
## 11 2018-01-11   17  14     46     b
## 12 2018-01-12   19  40      7     m
## 13 2018-01-13   22  44     49     n
## 14 2018-01-14    3  24     26     o
## 15 2018-01-15    5  51      2     p</code></pre>
<pre class="r"><code>data %&gt;% unite(datetime, hour, min, second, sep = &quot;:&quot;)</code></pre>
<pre><code>##          date datetime event
## 1  2018-01-01 16:49:30     h
## 2  2018-01-02 24:43:23     c
## 3  2018-01-03  8:42:29     i
## 4  2018-01-04 14:58:56     t
## 5  2018-01-05  4:31:54     e
## 6  2018-01-06 18:23:42     a
## 7  2018-01-07 21:59:57     k
## 8  2018-01-08 23:25:33     s
## 9  2018-01-09  15:2:19     x
## 10 2018-01-10  6:11:58     g
## 11 2018-01-11 17:14:46     b
## 12 2018-01-12  19:40:7     m
## 13 2018-01-13 22:44:49     n
## 14 2018-01-14  3:24:26     o
## 15 2018-01-15   5:51:2     p</code></pre>
<pre class="r"><code># the default separator is &quot;_&quot;, so if that doesn&#39;t work, change it as necessary</code></pre>
<p>The <code>unite</code> function is also helpful when you need to spread multiple columns in a dataframe.</p>
<pre class="r"><code>df &lt;- data.frame(quarter=rep(1:4,2),
                 section=rep(c(&quot;Sec1&quot;, &quot;Sec2&quot;), each=4),
                 QA=c(.9, .7, .6, .8, .6, .9, 1.0, .6),
                 QB=c(.6, .7, .8, .5, .6, .7, .5, .9))

df</code></pre>
<pre><code>##   quarter section  QA  QB
## 1       1    Sec1 0.9 0.6
## 2       2    Sec1 0.7 0.7
## 3       3    Sec1 0.6 0.8
## 4       4    Sec1 0.8 0.5
## 5       1    Sec2 0.6 0.6
## 6       2    Sec2 0.9 0.7
## 7       3    Sec2 1.0 0.5
## 8       4    Sec2 0.6 0.9</code></pre>
<p>What if we want to spread this so that each column relates to a section and a class average on two quizzes each quarter? We would use a lot of what the <code>tidyr</code> package has to offer - gather, unite, and then spread.</p>
<pre class="r"><code>df &lt;- data.frame(quarter=rep(1:4,2),
                 section=rep(c(&quot;Sec1&quot;, &quot;Sec2&quot;), each=4),
                 QA=c(.9, .7, .6, .8, .6, .9, 1.0, .6),
                 QB=c(.6, .7, .8, .5, .6, .7, .5, .9))


df &lt;- df %&gt;% 
  gather(variable, value, -(quarter:section)) %&gt;%
  unite(tmp, section, variable) %&gt;%
  spread(tmp, value)

df</code></pre>
<pre><code>##   quarter Sec1_QA Sec1_QB Sec2_QA Sec2_QB
## 1       1     0.9     0.6     0.6     0.6
## 2       2     0.7     0.7     0.9     0.7
## 3       3     0.6     0.8     1.0     0.5
## 4       4     0.8     0.5     0.6     0.9</code></pre>
</div>
